本文档记录使用过程中的一些心得，以及一些问题，包括对问题的跟踪结果。


## 名称约束
bootloader：bl
dosbox：com

## Q&&A
Q1：之前发现vbox和dosbox中效果不一样，有时候某些程序再dosbox中运行正常，而在vbox中运行异常。
A：因为编译的bl大小不符合512字节，目前看到的问题文件都是大于512字节。
1）字符串部分在512字节以外（这回导致字符串处理的部分，结果不符合预期）
2）或者55aa标志在512字节以外(这会导致开机执行不了)
这部分内容不会被bl加载进内存，所以程序运行会有问题。而com文件则没这个限制。

Q2&&A：接上。
发现只要包含section .data，编译的结果就会大于512字节。
如果，不使用.data，仅包含.text没有问题。
包含.bss也没有问题
未比对是否位系统不一样，或者nasm版本不同导致的。
更新-1:使用最新版2.11.08测试过，仍然是大于512字节


所以，对于bl程序，需要检查编译结果的大小，以及使用HexViewer 查看十六进制内容。

Q3: （实模式，binary格式）因为不能使用section .data, 所以如果将data部分的内容，放在asm文件的首部，
那么程序加载的时候，第一条指令其实是我们定义的初始化数据，会导致不可预期的结果。
这个可以对比生成的目标文件的二进制内容。
所以，应该将data部分放在程序的尾部(以0填充的区域的前面)，以防止处理器执行到数据部分。




$:	表示当前指令所在的地址
$$:	表示当前section的首地址

由于.bss的特殊性，它只是相当于一个声明，所以不影响最后的目标文件的大小。
binary格式
据目前的理解，编译器会顺序将每个section翻译成机器码，他们是顺序在目标文件中排列下去。

回到源程序，bl程序最后，一般会使用
times (512-($-$$) - 2)	db 0
db 0x55, 0xAA
来进行目标文件的填充，以保证目标文件大小为512字节

如果，源码中包含多于1个的section，那么上述填充0的部分，会算在离他最近的那个section，$$也会等价于该section的起始地址

举例，示例源码如下
section a
section b
section c
times (512-($-$$) - 2)	db 0
db 0x55, 0xAA

此时，$表示的是当前的这条指令的地址，$$表示section c的地址
那么(512-($-$$) - 2)没有将a和b算在内，正确的算法应该是
(512-($-section a地址) -2.
上述错误的写法，最终文件大小应该是512+section a的大小+section b的大小；